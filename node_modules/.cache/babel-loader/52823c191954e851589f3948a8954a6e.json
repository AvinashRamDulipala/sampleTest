{"ast":null,"code":"var _class, _temp, _initialiseProps;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport t from 'prop-types';\nimport React from 'react';\n\nfunction makeLookup(arr, prop) {\n  var lkup = {};\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    if (prop) {\n      lkup[arr[i][prop]] = true;\n    } else {\n      lkup[arr[i]] = true;\n    }\n  }\n\n  return lkup;\n}\n\nfunction getItemsByProp(arr, prop, values) {\n  var items = [];\n  var found = 0;\n  var valuesLookup = makeLookup(values);\n\n  for (var i = 0, la = arr.length, lv = values.length; i < la && found < lv; i++) {\n    if (valuesLookup[arr[i][prop]]) {\n      items.push(arr[i]);\n      found++;\n    }\n  }\n\n  return items;\n}\n\nvar DEFAULT_CLASS_NAMES = {\n  button: 'FilteredMultiSelect__button',\n  buttonActive: 'FilteredMultiSelect__button--active',\n  filter: 'FilteredMultiSelect__filter',\n  select: 'FilteredMultiSelect__select'\n};\nvar FilteredMultiSelect = (_temp = _class = function (_React$Component) {\n  _inherits(FilteredMultiSelect, _React$Component);\n\n  function FilteredMultiSelect(props) {\n    _classCallCheck(this, FilteredMultiSelect);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var defaultFilter = props.defaultFilter,\n        selectedOptions = props.selectedOptions;\n    _this.state = {\n      // Filter text\n      filter: defaultFilter,\n      // Options which haven't been selected and match the filter text\n      filteredOptions: _this._filterOptions(defaultFilter, selectedOptions),\n      // Values of <options> currently selected in the <select>\n      selectedValues: []\n    };\n    return _this;\n  }\n\n  FilteredMultiSelect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    // Update visible options in response to options or selectedOptions\n    // changing. Also update selected values after the re-render completes, as\n    // one of the previously selected options may have been removed.\n    if (nextProps.options !== this.props.options || nextProps.selectedOptions !== this.props.selectedOptions || nextProps.options.length !== this.props.options.length || nextProps.selectedOptions.length !== this.props.selectedOptions.length) {\n      this.setState({\n        filteredOptions: this._filterOptions(this.state.filter, nextProps.selectedOptions, nextProps.options)\n      }, this._updateSelectedValues);\n    }\n  };\n\n  FilteredMultiSelect.prototype._getClassName = function _getClassName(name) {\n    var classNames = [this.props.classNames[name] || DEFAULT_CLASS_NAMES[name]];\n\n    for (var _len = arguments.length, modifiers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      modifiers[_key - 1] = arguments[_key];\n    }\n\n    for (var i = 0, l = modifiers.length; i < l; i++) {\n      if (modifiers[i]) {\n        classNames.push(this.props.classNames[modifiers[i]] || DEFAULT_CLASS_NAMES[modifiers[i]]);\n      }\n    }\n\n    return classNames.join(' ');\n  };\n\n  FilteredMultiSelect.prototype._filterOptions = function _filterOptions(filter, selectedOptions, options) {\n    if (typeof filter == 'undefined') {\n      filter = this.state.filter;\n    }\n\n    if (typeof selectedOptions == 'undefined') {\n      selectedOptions = this.props.selectedOptions;\n    }\n\n    if (typeof options == 'undefined') {\n      options = this.props.options;\n    }\n\n    filter = filter.toUpperCase();\n    var _props = this.props,\n        textProp = _props.textProp,\n        valueProp = _props.valueProp;\n    var selectedValueLookup = makeLookup(selectedOptions, valueProp);\n    var filteredOptions = [];\n\n    for (var i = 0, l = options.length; i < l; i++) {\n      if (!selectedValueLookup[options[i][valueProp]] && (!filter || options[i][textProp].toUpperCase().indexOf(filter) !== -1)) {\n        filteredOptions.push(options[i]);\n      }\n    }\n\n    return filteredOptions;\n  };\n  /**\n   * Adds backing objects for the currently selected options to the selection\n   * and calls back with the new list.\n   */\n\n\n  FilteredMultiSelect.prototype.render = function render() {\n    var _state = this.state,\n        filter = _state.filter,\n        filteredOptions = _state.filteredOptions,\n        selectedValues = _state.selectedValues;\n    var _props2 = this.props,\n        className = _props2.className,\n        disabled = _props2.disabled,\n        placeholder = _props2.placeholder,\n        showFilter = _props2.showFilter,\n        size = _props2.size,\n        textProp = _props2.textProp,\n        valueProp = _props2.valueProp;\n    var hasSelectedOptions = selectedValues.length > 0;\n    return React.createElement('div', {\n      className: className\n    }, showFilter && React.createElement('input', {\n      type: 'text',\n      className: this._getClassName('filter'),\n      placeholder: placeholder,\n      value: filter,\n      onChange: this._onFilterChange,\n      onKeyPress: this._onFilterKeyPress,\n      disabled: disabled\n    }), React.createElement('select', {\n      multiple: true,\n      ref: this._selectRef,\n      className: this._getClassName('select'),\n      size: size,\n      value: selectedValues,\n      onChange: this._updateSelectedValues,\n      onDoubleClick: this._addSelectedToSelection,\n      disabled: disabled\n    }, filteredOptions.map(function (option) {\n      return React.createElement('option', {\n        key: option[valueProp],\n        value: option[valueProp]\n      }, option[textProp]);\n    })), React.createElement('button', {\n      type: 'button',\n      className: this._getClassName('button', hasSelectedOptions && 'buttonActive'),\n      disabled: !hasSelectedOptions,\n      onClick: this._addSelectedToSelection\n    }, this.props.buttonText));\n  };\n\n  return FilteredMultiSelect;\n}(React.Component), _class.defaultProps = {\n  buttonText: 'Select',\n  className: 'FilteredMultiSelect',\n  classNames: {},\n  defaultFilter: '',\n  disabled: false,\n  placeholder: 'type to filter',\n  selectedOptions: [],\n  showFilter: true,\n  size: 6,\n  textProp: 'text',\n  valueProp: 'value'\n}, _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this._selectRef = function (select) {\n    _this2._select = select;\n  };\n\n  this._onFilterChange = function (e) {\n    var filter = e.target.value;\n\n    _this2.setState({\n      filter: filter,\n      filteredOptions: _this2._filterOptions(filter)\n    }, _this2._updateSelectedValues);\n  };\n\n  this._onFilterKeyPress = function (e) {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n\n      if (_this2.state.filteredOptions.length === 1) {\n        var selectedOption = _this2.state.filteredOptions[0];\n\n        var selectedOptions = _this2.props.selectedOptions.concat([selectedOption]);\n\n        _this2.setState({\n          filter: '',\n          selectedValues: []\n        }, function () {\n          _this2.props.onChange(selectedOptions);\n        });\n      }\n    }\n  };\n\n  this._updateSelectedValues = function (e) {\n    var el = e ? e.target : _this2._select;\n    var selectedValues = [];\n\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      if (el.options[i].selected) {\n        selectedValues.push(el.options[i].value);\n      }\n    } // Always update if we were handling an event, otherwise only update if\n    // selectedValues has actually changed.\n\n\n    if (e || String(_this2.state.selectedValues) !== String(selectedValues)) {\n      _this2.setState({\n        selectedValues: selectedValues\n      });\n    }\n  };\n\n  this._addSelectedToSelection = function (e) {\n    var selectedOptions = _this2.props.selectedOptions.concat(getItemsByProp(_this2.state.filteredOptions, _this2.props.valueProp, _this2.state.selectedValues));\n\n    _this2.setState({\n      selectedValues: []\n    }, function () {\n      _this2.props.onChange(selectedOptions);\n    });\n  };\n}, _temp);\nFilteredMultiSelect.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  onChange: t.func.isRequired,\n  options: t.array.isRequired,\n  buttonText: t.string,\n  className: t.string,\n  classNames: t.object,\n  defaultFilter: t.string,\n  disabled: t.bool,\n  placeholder: t.string,\n  selectedOptions: t.array,\n  showFilter: t.bool,\n  size: t.number,\n  textProp: t.string,\n  valueProp: t.string\n} : {};\nexport default FilteredMultiSelect;","map":null,"metadata":{},"sourceType":"module"}